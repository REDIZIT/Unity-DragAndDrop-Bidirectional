using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;

namespace B83.Win32
{
    public enum HookType : int
    {
        WH_JOURNALRECORD = 0,
        WH_JOURNALPLAYBACK = 1,
        WH_KEYBOARD = 2,
        WH_GETMESSAGE = 3,
        WH_CALLWNDPROC = 4,
        WH_CBT = 5,
        WH_SYSMSGFILTER = 6,
        WH_MOUSE = 7,
        WH_HARDWARE = 8,
        WH_DEBUG = 9,
        WH_SHELL = 10,
        WH_FOREGROUNDIDLE = 11,
        WH_CALLWNDPROCRET = 12,
        WH_KEYBOARD_LL = 13,
        WH_MOUSE_LL = 14
    }

    // windows messages
    public enum WM : uint
    {
        NULL = 0x0000,
        CREATE = 0x0001,
        DESTROY = 0x0002,
        MOVE = 0x0003,
        SIZE = 0x0005,
        ACTIVATE = 0x0006,
        SETFOCUS = 0x0007,
        KILLFOCUS = 0x0008,
        ENABLE = 0x000A,
        SETREDRAW = 0x000B,
        SETTEXT = 0x000C,
        GETTEXT = 0x000D,
        GETTEXTLENGTH = 0x000E,
        PAINT = 0x000F,
        CLOSE = 0x0010,
        QUERYENDSESSION = 0x0011,
        QUERYOPEN = 0x0013,
        ENDSESSION = 0x0016,
        QUIT = 0x0012,
        ERASEBKGND = 0x0014,
        SYSCOLORCHANGE = 0x0015,
        SHOWWINDOW = 0x0018,
        WININICHANGE = 0x001A,
        SETTINGCHANGE = WININICHANGE,
        DEVMODECHANGE = 0x001B,
        ACTIVATEAPP = 0x001C,
        FONTCHANGE = 0x001D,
        TIMECHANGE = 0x001E,
        CANCELMODE = 0x001F,
        SETCURSOR = 0x0020,
        MOUSEACTIVATE = 0x0021,
        CHILDACTIVATE = 0x0022,
        QUEUESYNC = 0x0023,
        GETMINMAXINFO = 0x0024,
        PAINTICON = 0x0026,
        ICONERASEBKGND = 0x0027,
        NEXTDLGCTL = 0x0028,
        SPOOLERSTATUS = 0x002A,
        DRAWITEM = 0x002B,
        MEASUREITEM = 0x002C,
        DELETEITEM = 0x002D,
        VKEYTOITEM = 0x002E,
        CHARTOITEM = 0x002F,
        SETFONT = 0x0030,
        GETFONT = 0x0031,
        SETHOTKEY = 0x0032,
        GETHOTKEY = 0x0033,
        QUERYDRAGICON = 0x0037,
        COMPAREITEM = 0x0039,
        GETOBJECT = 0x003D,
        COMPACTING = 0x0041,
        [Obsolete]
        COMMNOTIFY = 0x0044,
        WINDOWPOSCHANGING = 0x0046,
        WINDOWPOSCHANGED = 0x0047,
        [Obsolete]
        POWER = 0x0048,
        COPYDATA = 0x004A,
        CANCELJOURNAL = 0x004B,
        NOTIFY = 0x004E,
        INPUTLANGCHANGEREQUEST = 0x0050,
        INPUTLANGCHANGE = 0x0051,
        TCARD = 0x0052,
        HELP = 0x0053,
        USERCHANGED = 0x0054,
        NOTIFYFORMAT = 0x0055,
        CONTEXTMENU = 0x007B,
        STYLECHANGING = 0x007C,
        STYLECHANGED = 0x007D,
        DISPLAYCHANGE = 0x007E,
        GETICON = 0x007F,
        SETICON = 0x0080,
        NCCREATE = 0x0081,
        NCDESTROY = 0x0082,
        NCCALCSIZE = 0x0083,
        NCHITTEST = 0x0084,
        NCPAINT = 0x0085,
        NCACTIVATE = 0x0086,
        GETDLGCODE = 0x0087,
        SYNCPAINT = 0x0088,
        NCMOUSEMOVE = 0x00A0,
        NCLBUTTONDOWN = 0x00A1,
        NCLBUTTONUP = 0x00A2,
        NCLBUTTONDBLCLK = 0x00A3,
        NCRBUTTONDOWN = 0x00A4,
        NCRBUTTONUP = 0x00A5,
        NCRBUTTONDBLCLK = 0x00A6,
        NCMBUTTONDOWN = 0x00A7,
        NCMBUTTONUP = 0x00A8,
        NCMBUTTONDBLCLK = 0x00A9,
        NCXBUTTONDOWN = 0x00AB,
        NCXBUTTONUP = 0x00AC,
        NCXBUTTONDBLCLK = 0x00AD,
        INPUT_DEVICE_CHANGE = 0x00FE,
        INPUT = 0x00FF,
        KEYFIRST = 0x0100,
        KEYDOWN = 0x0100,
        KEYUP = 0x0101,
        CHAR = 0x0102,
        DEADCHAR = 0x0103,
        SYSKEYDOWN = 0x0104,
        SYSKEYUP = 0x0105,
        SYSCHAR = 0x0106,
        SYSDEADCHAR = 0x0107,
        UNICHAR = 0x0109,
        KEYLAST = 0x0108,
        IME_STARTCOMPOSITION = 0x010D,
        IME_ENDCOMPOSITION = 0x010E,
        IME_COMPOSITION = 0x010F,
        IME_KEYLAST = 0x010F,
        INITDIALOG = 0x0110,
        COMMAND = 0x0111,
        SYSCOMMAND = 0x0112,
        TIMER = 0x0113,
        HSCROLL = 0x0114,
        VSCROLL = 0x0115,
        INITMENU = 0x0116,
        INITMENUPOPUP = 0x0117,
        MENUSELECT = 0x011F,
        MENUCHAR = 0x0120,
        ENTERIDLE = 0x0121,
        MENURBUTTONUP = 0x0122,
        MENUDRAG = 0x0123,
        MENUGETOBJECT = 0x0124,
        UNINITMENUPOPUP = 0x0125,
        MENUCOMMAND = 0x0126,
        CHANGEUISTATE = 0x0127,
        UPDATEUISTATE = 0x0128,
        QUERYUISTATE = 0x0129,
        CTLCOLORMSGBOX = 0x0132,
        CTLCOLOREDIT = 0x0133,
        CTLCOLORLISTBOX = 0x0134,
        CTLCOLORBTN = 0x0135,
        CTLCOLORDLG = 0x0136,
        CTLCOLORSCROLLBAR = 0x0137,
        CTLCOLORSTATIC = 0x0138,
        MOUSEFIRST = 0x0200,
        MOUSEMOVE = 0x0200,
        LBUTTONDOWN = 0x0201,
        LBUTTONUP = 0x0202,
        LBUTTONDBLCLK = 0x0203,
        RBUTTONDOWN = 0x0204,
        RBUTTONUP = 0x0205,
        RBUTTONDBLCLK = 0x0206,
        MBUTTONDOWN = 0x0207,
        MBUTTONUP = 0x0208,
        MBUTTONDBLCLK = 0x0209,
        MOUSEWHEEL = 0x020A,
        XBUTTONDOWN = 0x020B,
        XBUTTONUP = 0x020C,
        XBUTTONDBLCLK = 0x020D,
        MOUSEHWHEEL = 0x020E,
        MOUSELAST = 0x020E,
        PARENTNOTIFY = 0x0210,
        ENTERMENULOOP = 0x0211,
        EXITMENULOOP = 0x0212,
        NEXTMENU = 0x0213,
        SIZING = 0x0214,
        CAPTURECHANGED = 0x0215,
        MOVING = 0x0216,
        POWERBROADCAST = 0x0218,
        DEVICECHANGE = 0x0219,
        MDICREATE = 0x0220,
        MDIDESTROY = 0x0221,
        MDIACTIVATE = 0x0222,
        MDIRESTORE = 0x0223,
        MDINEXT = 0x0224,
        MDIMAXIMIZE = 0x0225,
        MDITILE = 0x0226,
        MDICASCADE = 0x0227,
        MDIICONARRANGE = 0x0228,
        MDIGETACTIVE = 0x0229,
        MDISETMENU = 0x0230,
        ENTERSIZEMOVE = 0x0231,
        EXITSIZEMOVE = 0x0232,
        DROPFILES = 0x0233,
        MDIREFRESHMENU = 0x0234,
        IME_SETCONTEXT = 0x0281,
        IME_NOTIFY = 0x0282,
        IME_CONTROL = 0x0283,
        IME_COMPOSITIONFULL = 0x0284,
        IME_SELECT = 0x0285,
        IME_CHAR = 0x0286,
        IME_REQUEST = 0x0288,
        IME_KEYDOWN = 0x0290,
        IME_KEYUP = 0x0291,
        MOUSEHOVER = 0x02A1,
        MOUSELEAVE = 0x02A3,
        NCMOUSEHOVER = 0x02A0,
        NCMOUSELEAVE = 0x02A2,
        WTSSESSION_CHANGE = 0x02B1,
        TABLET_FIRST = 0x02c0,
        TABLET_LAST = 0x02df,
        CUT = 0x0300,
        COPY = 0x0301,
        PASTE = 0x0302,
        CLEAR = 0x0303,
        UNDO = 0x0304,
        RENDERFORMAT = 0x0305,
        RENDERALLFORMATS = 0x0306,
        DESTROYCLIPBOARD = 0x0307,
        DRAWCLIPBOARD = 0x0308,
        PAINTCLIPBOARD = 0x0309,
        VSCROLLCLIPBOARD = 0x030A,
        SIZECLIPBOARD = 0x030B,
        ASKCBFORMATNAME = 0x030C,
        CHANGECBCHAIN = 0x030D,
        HSCROLLCLIPBOARD = 0x030E,
        QUERYNEWPALETTE = 0x030F,
        PALETTEISCHANGING = 0x0310,
        PALETTECHANGED = 0x0311,
        HOTKEY = 0x0312,
        PRINT = 0x0317,
        PRINTCLIENT = 0x0318,
        APPCOMMAND = 0x0319,
        THEMECHANGED = 0x031A,
        CLIPBOARDUPDATE = 0x031D,
        DWMCOMPOSITIONCHANGED = 0x031E,
        DWMNCRENDERINGCHANGED = 0x031F,
        DWMCOLORIZATIONCOLORCHANGED = 0x0320,
        DWMWINDOWMAXIMIZEDCHANGE = 0x0321,
        GETTITLEBARINFOEX = 0x033F,
        HANDHELDFIRST = 0x0358,
        HANDHELDLAST = 0x035F,
        AFXFIRST = 0x0360,
        AFXLAST = 0x037F,
        PENWINFIRST = 0x0380,
        PENWINLAST = 0x038F,
        APP = 0x8000,
        USER = 0x0400,
        CPL_LAUNCH = USER + 0x1000,
        CPL_LAUNCHED = USER + 0x1001,
        SYSTIMER = 0x118,
    }

    // WH_CALLWNDPROC
    [StructLayout(LayoutKind.Sequential)]
    public struct CWPSTRUCT
    {
        public IntPtr lParam;
        public IntPtr wParam;
        public WM message;
        public IntPtr hwnd;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    {
        public int x, y;
        public POINT(int aX, int aY)
        {
            x = aX;
            y = aY;
        }
        public override string ToString()
        {
            return "(" + x + ", " + y + ")";
        }
    }

    //WH_GETMESSAGE
    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    {
        public IntPtr hwnd;
        public WM message;
        public IntPtr wParam;
        public IntPtr lParam;
        public ushort time;
        public POINT pt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    {
        public int Left, Top, Right, Bottom;

        public RECT(int left, int top, int right, int bottom)
        {
            Left = left;
            Top = top;
            Right = right;
            Bottom = bottom;
        }
        public override string ToString()
        {
            return "(" + Left + ", " + Top + ", " + Right + ", " + Bottom + ")";
        }
    }

    public delegate IntPtr HookProc(int code, IntPtr wParam, ref MSG lParam);
    public delegate bool EnumThreadDelegate(IntPtr Hwnd, IntPtr lParam);

#if UNITY_STANDALONE_WIN || UNITY_EDITOR_WIN

    public static class Window
    {
        [DllImport("user32.dll")]
        public static extern bool EnumThreadWindows(uint dwThreadId, EnumThreadDelegate lpfn, IntPtr lParam);

        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);

        [DllImport("user32.dll")]
        public static extern bool IsWindowVisible(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern int GetClassName(IntPtr hWnd, System.Text.StringBuilder lpClassName, int nMaxCount);
        public static string GetClassName(IntPtr hWnd)
        {
            var sb = new System.Text.StringBuilder(256);
            int count = GetClassName(hWnd, sb, 256);
            return sb.ToString(0, count);
        }

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern int GetWindowTextLength(IntPtr hWnd);
        [DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
        public static string GetWindowText(IntPtr hWnd)
        {
            int length = GetWindowTextLength(hWnd) + 2;
            var sb = new System.Text.StringBuilder(length);
            int count = GetWindowText(hWnd, sb, length);
            return sb.ToString(0, count);
        }
    }

    public static class WinAPI
    {
        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("kernel32.dll")]
        public static extern uint GetCurrentThreadId();

        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SetWindowsHookEx(HookType hookType, HookProc lpfn, IntPtr hMod, uint dwThreadId);
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool UnhookWindowsHookEx(IntPtr hhk);
        [DllImport("user32.dll")]
        public static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, ref MSG lParam);

        [DllImport("shell32.dll")]
        public static extern void DragAcceptFiles(IntPtr hwnd, bool fAccept);
        [DllImport("shell32.dll", CharSet = CharSet.Unicode)]
        public static extern uint DragQueryFile(IntPtr hDrop, uint iFile, System.Text.StringBuilder lpszFile, uint cch);
        [DllImport("shell32.dll")]
        public static extern void DragFinish(IntPtr hDrop);

        [DllImport("shell32.dll")]
        public static extern void DragQueryPoint(IntPtr hDrop, out POINT pos);

        [DllImport("ole32.dll", ExactSpelling = true, CharSet = CharSet.Auto)]
        public static extern int DoDragDrop(
            [In, MarshalAs(UnmanagedType.IUnknown)] IDataObject pDataObject,
            [In, MarshalAs(UnmanagedType.IUnknown)] IDropSource pDropSource,
            [In] DROPEFFECT dwOKEffects,
            [Out] out DROPEFFECT pdwEffect);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern ushort RegisterClipboardFormat(string lpszFormat);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr GlobalAlloc(uint uFlags, UIntPtr dwBytes);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr GlobalLock(IntPtr hMem);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GlobalUnlock(IntPtr hMem);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr GlobalFree(IntPtr hMem);

        // Флаги для GlobalAlloc
        public const uint GMEM_MOVEABLE = 0x0002;
        public const uint GMEM_ZEROINIT = 0x0040;

        // Инициализация COM (часто не требуется, т.к. Unity это делает, но хорошая практика)
        [DllImport("ole32.dll")]
        public static extern int OleInitialize(IntPtr pvReserved);
        [DllImport("ole32.dll")]
        public static extern void OleUninitialize(); // Для корректного завершения, если OleInitialize был вызван
    }
#endif


    public static class UnityDragAndDropHook
    {
        public delegate void DroppedFilesEvent(List<string> aPathNames, POINT aDropPoint);
        public static event DroppedFilesEvent OnDroppedFiles;

#if UNITY_STANDALONE_WIN && !UNITY_EDITOR_WIN

        private static uint threadId;
        private static IntPtr mainWindow = IntPtr.Zero;
        private static IntPtr m_Hook;
        private static string m_ClassName = "UnityWndClass";
        private static bool s_IsDraggingOut = false; // ДОБАВЛЕНО: Флаг для отслеживания активного Drag-Out

        // attribute required for IL2CPP, also has to be a static method
        [AOT.MonoPInvokeCallback(typeof(EnumThreadDelegate))]
        private static bool EnumCallback(IntPtr W, IntPtr _)
        {
            if (Window.IsWindowVisible(W) && (mainWindow == IntPtr.Zero || (m_ClassName != null && Window.GetClassName(W) == m_ClassName)))
            {
                mainWindow = W;
            }
            return true;
        }

        public static void InstallHook()
        {
            threadId = WinAPI.GetCurrentThreadId();
            if (threadId > 0)
                Window.EnumThreadWindows(threadId, EnumCallback, IntPtr.Zero);

            var hModule = WinAPI.GetModuleHandle(null);
            m_Hook = WinAPI.SetWindowsHookEx(HookType.WH_GETMESSAGE, Callback, hModule, threadId);
            // Allow dragging of files onto the main window. generates the WM_DROPFILES message
            WinAPI.DragAcceptFiles(mainWindow, true);
        }
        public static void UninstallHook()
        {
            WinAPI.UnhookWindowsHookEx(m_Hook);
            WinAPI.DragAcceptFiles(mainWindow, false);
            m_Hook = IntPtr.Zero;
        }

        [AOT.MonoPInvokeCallback(typeof(HookProc))]
        private static IntPtr Callback(int code, IntPtr wParam, ref MSG lParam)
        {
            if (code == 0 && lParam.message == WM.DROPFILES)
            {
                POINT pos;
                WinAPI.DragQueryPoint(lParam.wParam, out pos);

                uint n = WinAPI.DragQueryFile(lParam.wParam, 0xFFFFFFFF, null, 0);
                var sb = new System.Text.StringBuilder(1024);

                List<string> result = new List<string>();
                for (uint i = 0; i < n; i++)
                {
                    int len = (int)WinAPI.DragQueryFile(lParam.wParam, i, sb, 1024);
                    result.Add(sb.ToString(0, len));
                    sb.Length = 0;
                }

                // ИЗМЕНЕНО: Вызываем DragFinish только если это не наш собственный Drag-Out
                if (!s_IsDraggingOut)
                {
                    WinAPI.DragFinish(lParam.wParam);
                    Debug.Log("Called DragFinish for external drop.");
                }
                else
                {
                    Debug.Log("Skipping DragFinish for self-drop during active drag-out operation.");
                }

                if (OnDroppedFiles != null)
                    OnDroppedFiles(result, pos);
            }
            return WinAPI.CallNextHookEx(m_Hook, code, wParam, ref lParam);
        }

        public static void StartDragFiles(List<string> filePaths)
        {
            if (filePaths == null || filePaths.Count == 0)
            {
                Debug.LogWarning("No files provided for drag operation.");
                return;
            }

            bool oleInitializedByUs = false;
            int hrOle = WinAPI.OleInitialize(IntPtr.Zero);
            if (hrOle == HRESULT.S_OK || hrOle == HRESULT.S_FALSE)
            {
                oleInitializedByUs = (hrOle == HRESULT.S_OK);
            }
            else
            {
                Debug.LogError($"OleInitialize failed with HRESULT: {hrOle}");
                return;
            }

            // Создаем экземпляры объектов IDataObject и IDropSource
            IDataObject dataObject = new FileDataObject(filePaths);
            IDropSource dropSource = new FileDropSource();

            DROPEFFECT resultEffect;
            s_IsDraggingOut = true;
            try
            {
                // Вызываем нативную функцию DoDragDrop
                int hr = WinAPI.DoDragDrop(dataObject, dropSource,
                                        DROPEFFECT.DROPEFFECT_COPY | DROPEFFECT.DROPEFFECT_MOVE | DROPEFFECT.DROPEFFECT_LINK,
                                        out resultEffect);

                if (hr == HRESULT.DRAGDROP_S_DROP)
                {
                    Debug.Log($"Drag operation completed with effect: {resultEffect}");
                    // Здесь можно добавить логику, если, например, это было перемещение (DROPEFFECT_MOVE),
                    // то удалить оригинальные файлы.
                }
                else if (hr == HRESULT.DRAGDROP_S_CANCEL)
                {
                    Debug.Log("Drag operation cancelled.");
                }
                else
                {
                    Debug.LogError($"DoDragDrop failed with HRESULT: {hr}");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"Exception during DoDragDrop: {ex.Message}");
            }
            finally
            {
                s_IsDraggingOut = false;
                if (oleInitializedByUs)
                {
                    WinAPI.OleUninitialize();
                }
                // ДОБАВЛЕНО: Явно указываем сборщику мусора, что эти объекты используются
                // до завершения метода, чтобы они не были собраны во время нативного вызова.
                GC.KeepAlive(dataObject);
                GC.KeepAlive(dropSource);
            }
        }
#else
        public static void InstallHook()
        {
        }
        public static void UninstallHook()
        {
        }
        public static void StartDragFiles(List<string> filePaths)
        {
        }
#endif
    }





    public enum DVASPECT : int
    {
        DVASPECT_CONTENT = 1,
        DVASPECT_THUMBNAIL = 2,
        DVASPECT_ICON = 4,
        DVASPECT_DOCPRINT = 8
    }

    public enum TYMED : int
    {
        TYMED_HGLOBAL = 1,
        TYMED_FILE = 2,
        TYMED_ISTREAM = 4,
        TYMED_ISTORAGE = 8,
        TYMED_GDI = 16,
        TYMED_MFPICT = 32,
        TYMED_ENHMF = 64,
        TYMED_NULL = 0
    }

    [Flags]
    public enum DROPEFFECT : int
    {
        DROPEFFECT_NONE = 0,
        DROPEFFECT_COPY = 1,
        DROPEFFECT_MOVE = 2,
        DROPEFFECT_LINK = 4,
        DROPEFFECT_SCROLL = unchecked((int)0x80000000)
    }

    // Добавленные Structs для Drag & Drop
    [StructLayout(LayoutKind.Sequential)]
    public struct FORMATETC
    {
        public short cfFormat;
        public DVASPECT dwAspect;
        public TYMED tymed;
        public int lindex;
        public IntPtr ptd; // Pointer to DVTARGETDEVICE, often null for simple data
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct STGMEDIUM
    {
        public TYMED tymed;
        public IntPtr hGlobal; // Or hBitmap, hMetaFilePict, etc.
        public IntPtr pUnkForRelease; // IUnknown*
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct STATDATA // НОВАЯ СТРУКТУРА
    {
        public FORMATETC formatetc;
        public ADVF advf;
        [MarshalAs(UnmanagedType.Interface)] // Это IAdviseSink*
        public IAdviseSink pAdvSink;
        public uint dwConnection;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct DROPFILES
    {
        public uint pFiles; // Offset to the file list from the beginning of this structure
        public POINT pt;    // Drop point (not relevant for source)
        [MarshalAs(UnmanagedType.Bool)]
        public bool fNC;    // Non-client area (not relevant for source)
        [MarshalAs(UnmanagedType.Bool)]
        public bool fWide;  // TRUE if file names are Unicode
    }

    [ComImport]
    [Guid("00000121-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IDropSource
    {
        [PreserveSig]
        int QueryContinueDrag(
            [In, MarshalAs(UnmanagedType.Bool)] bool fEscapePressed, // ИСПРАВЛЕНО (с int на bool, добавлен MarshalAs)
            [In] int grfKeyState);

        [PreserveSig]
        int GiveFeedback(
            [In] DROPEFFECT dwEffect);
    }

    [ComImport]
    [Guid("0000010E-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IDataObject
    {
        [PreserveSig]
        int GetData(
            [In] ref FORMATETC pFormatEtc,
            [Out] out STGMEDIUM pStgMedium);

        [PreserveSig]
        int GetDataHere(
            [In] ref FORMATETC pFormatEtc,
            [In, Out] ref STGMEDIUM pStgMedium);

        [PreserveSig]
        int QueryGetData(
            [In] ref FORMATETC pFormatEtc);

        [PreserveSig]
        int GetCanonicalFormatEtc(
            [In] ref FORMATETC pFormatEtcIn,
            [Out] out FORMATETC pFormatEtcOut);

        [PreserveSig]
        int SetData(
            [In] ref FORMATETC pFormatEtc,
            [In] ref STGMEDIUM pStgMedium,
            [In, MarshalAs(UnmanagedType.Bool)] bool fRelease); // ИСПРАВЛЕНО

        [PreserveSig]
        int EnumFormatEtc(
            [In] DATADIR dwDirection,
            [Out, MarshalAs(UnmanagedType.Interface)] out IEnumFORMATETC ppEnumFormatEtc); // ИСПРАВЛЕНО

        [PreserveSig]
        int DAdvise(
            [In] ref FORMATETC pFormatEtc,
            [In] ADVF grfAdvf,
            [In, MarshalAs(UnmanagedType.Interface)] IAdviseSink pAdvSink, // ИСПРАВЛЕНО
            [Out] out uint pdwConnection);

        [PreserveSig]
        int DUnadvise(
            [In] uint dwConnection);

        [PreserveSig]
        int EnumDAdvise(
            [Out, MarshalAs(UnmanagedType.Interface)] out IEnumSTATDATA ppEnumAdvise); // ИСПРАВЛЕНО
    }

    // Вспомогательные интерфейсы/перечисления для IDataObject (минимально необходимые)
    public enum DATADIR
    {
        DATADIR_GET = 1,
        DATADIR_SET = 2
    }

    [Flags]
    public enum ADVF : int
    {
        ADVF_NODATA = 1,
        ADVF_PRIMEFIRST = 2,
        ADVF_ONLYONCE = 4,
        ADVF_DATAONSTOP = 8,
        ADVFCACHE_NOHANDLER = 16,
        ADVFCACHE_FORCEBUILTIN = 32,
        ADVFCACHE_ONSAVE = 64
    }

    [ComImport]
    [Guid("0000010F-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IAdviseSink
    {
        [PreserveSig]
        void OnDataChange([In] ref FORMATETC pFormatEtc, [In] ref STGMEDIUM pStgMedium);
        [PreserveSig]
        void OnViewChange([In] uint dwAspect, [In] int lindex);
        [PreserveSig]
        void OnRename([In, MarshalAs(UnmanagedType.IUnknown)] object pmk); // IMoniker - ИСПРАВЛЕНО
        [PreserveSig]
        void OnSave();
        [PreserveSig]
        void OnClose();
    }

    [ComImport]
    [Guid("00000103-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumFORMATETC
    {
        [PreserveSig]
        int Next(
            [In] uint celt,
            [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] FORMATETC[] rgelt,
            [Out] out uint pceltFetched);

        [PreserveSig]
        int Skip([In] uint celt);

        [PreserveSig]
        int Reset();

        [PreserveSig]
        int Clone(
            [Out] out IEnumFORMATETC ppEnum);
    }

    [ComImport]
    [Guid("00000105-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumSTATDATA
    {
        // ИСПРАВЛЕНО: Добавлены все методы IEnumSTATDATA
        [PreserveSig]
        int Next(
            [In] uint celt,
            [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] STATDATA[] rgelt,
            [Out] out uint pceltFetched);

        [PreserveSig]
        int Skip([In] uint celt);

        [PreserveSig]
        int Reset();

        [PreserveSig]
        int Clone(
            [Out] out IEnumSTATDATA ppEnum);
    }

    [ComVisible(true)]
    [ClassInterface(ClassInterfaceType.None)] // ДОБАВЛЕНО
    public class EnumStatData : IEnumSTATDATA
    {
        public int Next(uint celt, STATDATA[] rgelt, out uint pceltFetched)
        {
            pceltFetched = 0;
            // Возвращаем S_FALSE, чтобы указать, что нет данных для перечисления
            return HRESULT.S_FALSE;
        }

        public int Skip(uint celt)
        {
            return HRESULT.S_OK; // Успешно "пропущено" (т.к. ничего и не было)
        }

        public int Reset()
        {
            return HRESULT.S_OK; // Успешно "сброшено"
        }

        public int Clone(out IEnumSTATDATA ppEnum)
        {
            // Возвращаем новую заглушку-перечислитель
            ppEnum = new EnumStatData();
            return HRESULT.S_OK;
        }
    }


















    // Вспомогательный класс для общих констант Drag & Drop
public static class DragDropHelper
{
    // CF_HDROP - стандартный формат буфера обмена для списка файлов (значение 15)
    public const short CF_HDROP_VALUE = 15;
}

// Класс для обработки возвращаемых значений COM (HRESULT)
public static class HRESULT
{
    public const int S_OK = 0;
    public const int S_FALSE = 1;
    public const int E_NOTIMPL = unchecked((int)0x80004001);
    public const int E_OUTOFMEMORY = unchecked((int)0x8007000E);
    public const int E_POINTER = unchecked((int)0x80004003);
    public const int DV_E_FORMATETC = unchecked((int)0x80040064);

    public const int DRAGDROP_S_CANCEL = 0x00040101;
    public const int DRAGDROP_S_DROP = 0x00040100;
    public const int DRAGDROP_S_USEDEFAULTCURSORS = 0x00040102; // Специальный код для IDropSource.GiveFeedback
}

// Реализация IDataObject для предоставления списка файлов
[ComVisible(true)]
[ClassInterface(ClassInterfaceType.None)] // ДОБАВЛЕНО: Отключает автоматический Class Interface
public class FileDataObject : IDataObject
{
    private List<string> _filePaths;

    public FileDataObject(List<string> filePaths)
    {
        _filePaths = filePaths;
    }

    public int GetData(ref FORMATETC pFormatEtc, out STGMEDIUM pStgMedium)
    {
        pStgMedium = new STGMEDIUM();

        if (pFormatEtc.cfFormat == DragDropHelper.CF_HDROP_VALUE &&
            (pFormatEtc.tymed & TYMED.TYMED_HGLOBAL) != 0)
        {
            // Calculate total size needed for all paths including null terminators
            // Each path needs a null terminator, plus one final null terminator for the list
            int totalPathsByteSize = 0;
            List<byte[]> pathByteArrays = new List<byte[]>(); // Сначала сохраним байтовые представления путей
            foreach (string path in _filePaths)
            {
                // Получаем байты строки в кодировке Unicode (UTF-16)
                byte[] pathBytes = System.Text.Encoding.Unicode.GetBytes(path);
                pathByteArrays.Add(pathBytes);
                totalPathsByteSize += pathBytes.Length + 2; // +2 для Unicode нуль-терминатора (0x0000)
            }
            totalPathsByteSize += 2; // Для финального двойного нуль-терминатора (0x0000) для всего списка

            int dropFilesHeaderSize = Marshal.SizeOf(typeof(DROPFILES));
            uint totalAllocSize = (uint)(dropFilesHeaderSize + totalPathsByteSize);

            // Allocate global memory
            IntPtr hGlobal = WinAPI.GlobalAlloc(WinAPI.GMEM_MOVEABLE | WinAPI.GMEM_ZEROINIT, (UIntPtr)totalAllocSize);
            if (hGlobal == IntPtr.Zero)
                return HRESULT.E_OUTOFMEMORY;

            IntPtr pGlobal = WinAPI.GlobalLock(hGlobal);
            if (pGlobal == IntPtr.Zero)
            {
                WinAPI.GlobalFree(hGlobal);
                return HRESULT.E_OUTOFMEMORY;
            }

            try
            {
                // Write DROPFILES structure
                DROPFILES df = new DROPFILES();
                df.pFiles = (uint)dropFilesHeaderSize; // Offset to the file list from start of structure
                df.fWide = true; // Use Unicode strings
                Marshal.StructureToPtr(df, pGlobal, false);

                // Write file paths
                IntPtr currentDataPtr = (IntPtr)((long)pGlobal + dropFilesHeaderSize);
                foreach (byte[] pathBytes in pathByteArrays)
                {
                    Marshal.Copy(pathBytes, 0, currentDataPtr, pathBytes.Length);
                    currentDataPtr = (IntPtr)((long)currentDataPtr + pathBytes.Length);
                    Marshal.WriteInt16(currentDataPtr, 0); // Write Unicode null terminator (0x0000)
                    currentDataPtr = (IntPtr)((long)currentDataPtr + 2); // Advance past null terminator
                }
                Marshal.WriteInt16(currentDataPtr, 0); // Final double Unicode null terminator (0x0000)

                pStgMedium.tymed = TYMED.TYMED_HGLOBAL;
                pStgMedium.hGlobal = hGlobal;
                pStgMedium.pUnkForRelease = IntPtr.Zero; // System will free this memory via GlobalFree

                return HRESULT.S_OK;
            }
            finally
            {
                WinAPI.GlobalUnlock(hGlobal); // Decrements lock count, does not free memory
            }
        }
        return HRESULT.DV_E_FORMATETC;
    }

    // Остальные методы IDataObject (большей частью заглушки)
    public int GetDataHere(ref FORMATETC pFormatEtc, ref STGMEDIUM pStgMedium) { return HRESULT.E_NOTIMPL; }
    public int QueryGetData(ref FORMATETC pFormatEtc)
    {
        if (pFormatEtc.cfFormat == DragDropHelper.CF_HDROP_VALUE &&
            (pFormatEtc.tymed & TYMED.TYMED_HGLOBAL) != 0)
        {
            return HRESULT.S_OK; // Формат поддерживается
        }
        return HRESULT.S_FALSE; // Формат не поддерживается
    }
    public int GetCanonicalFormatEtc(ref FORMATETC pFormatEtcIn, out FORMATETC pFormatEtcOut)
    {
        pFormatEtcOut = new FORMATETC();
        return HRESULT.E_NOTIMPL;
    }
    public int SetData(ref FORMATETC pFormatEtc, ref STGMEDIUM pStgMedium, bool fRelease) { return HRESULT.E_NOTIMPL; }
    public int EnumFormatEtc(DATADIR dwDirection, out IEnumFORMATETC ppEnumFormatEtc)
    {
        if (dwDirection == DATADIR.DATADIR_GET)
        {
            FORMATETC[] formats = new FORMATETC[]
            {
                new FORMATETC { cfFormat = DragDropHelper.CF_HDROP_VALUE, tymed = TYMED.TYMED_HGLOBAL, dwAspect = DVASPECT.DVASPECT_CONTENT, lindex = -1, ptd = IntPtr.Zero }
            };
            ppEnumFormatEtc = new EnumFormatEtc(formats);
            return HRESULT.S_OK;
        }
        ppEnumFormatEtc = null;
        return HRESULT.E_NOTIMPL;
    }
    public int DAdvise(ref FORMATETC pFormatEtc, ADVF grfAdvf, IAdviseSink pAdvSink, out uint pdwConnection) { pdwConnection = 0; return HRESULT.E_NOTIMPL; }
    public int DUnadvise(uint dwConnection) { return HRESULT.E_NOTIMPL; }
    public int EnumDAdvise(out IEnumSTATDATA ppEnumAdvise)
    {
        // ИСПРАВЛЕНО: Возвращаем экземпляр заглушки EnumStatData
        ppEnumAdvise = new EnumStatData();
        return HRESULT.S_OK;
    }
}

[ComVisible(true)]
[ClassInterface(ClassInterfaceType.None)]
public class FileDropSource : IDropSource
{
    public int QueryContinueDrag(bool fEscapePressed, int grfKeyState)
    {
        // Если нажата Escape, отменяем перетаскивание
        if (fEscapePressed)
            return HRESULT.DRAGDROP_S_CANCEL;

        const int MK_LBUTTON = 0x0001; // Флаг состояния левой кнопки мыши

        // Если левая кнопка мыши отпущена (ее флаг не установлен в grfKeyState)
        // ИЛИ если правая/средняя кнопка мыши нажата (что часто означает отмену или изменение действия)
        // Возвращаем DRAGDROP_S_DROP, чтобы DoDragDrop мог завершить операцию
        // Если цель не примет дроп, DoDragDrop сам превратит это в DRAGDROP_S_CANCEL
        if ((grfKeyState & MK_LBUTTON) == 0) // Левая кнопка мыши отпущена
        {
            // Примечание: Возврат DRAGDROP_S_DROP здесь не означает, что дроп произошел,
            // а лишь сигнализирует DoDragDrop, что состояние позволяет завершить операцию.
            // DoDragDrop сам определит фактический результат.
            return HRESULT.DRAGDROP_S_DROP; // ИЗМЕНЕНО: Более явный сигнал о завершении
        }

        // Если другие кнопки мыши нажаты, это также может означать отмену
        // (например, правая кнопка во время левой - часто отмена в Drag/Drop)
        const int MK_RBUTTON = 0x0002;
        const int MK_MBUTTON = 0x0010;
        if ((grfKeyState & (MK_RBUTTON | MK_MBUTTON)) != 0) // ДОБАВЛЕНО: Проверка других кнопок
        {
            return HRESULT.DRAGDROP_S_CANCEL; // Отмена, если нажаты другие кнопки
        }


        return HRESULT.S_OK; // Продолжаем перетаскивание
    }

    public int GiveFeedback(DROPEFFECT dwEffect)
    {
        // Позволяем OLE использовать курсоры по умолчанию
        return HRESULT.DRAGDROP_S_USEDEFAULTCURSORS;
    }
}

// Вспомогательный класс для IEnumFORMATETC
[ComVisible(true)]
[ClassInterface(ClassInterfaceType.None)] // ДОБАВЛЕНО
public class EnumFormatEtc : IEnumFORMATETC
{
    private FORMATETC[] _formats;
    private int _currentIndex;

    public EnumFormatEtc(FORMATETC[] formats)
    {
        _formats = formats;
        _currentIndex = 0;
    }

    public int Next(uint celt, FORMATETC[] rgelt, out uint pceltFetched)
    {
        pceltFetched = 0;
        if (rgelt == null) return HRESULT.E_POINTER;

        for (int i = 0; i < celt && _currentIndex < _formats.Length; i++)
        {
            rgelt[i] = _formats[_currentIndex];
            _currentIndex++;
            pceltFetched++;
        }

        return (pceltFetched == celt) ? HRESULT.S_OK : HRESULT.S_FALSE;
    }

    public int Skip(uint celt)
    {
        _currentIndex += (int)celt;
        return (_currentIndex <= _formats.Length) ? HRESULT.S_OK : HRESULT.S_FALSE;
    }

    public int Reset()
    {
        _currentIndex = 0;
        return HRESULT.S_OK;
    }

    public int Clone(out IEnumFORMATETC ppEnum)
    {
        ppEnum = new EnumFormatEtc(_formats);
        ((EnumFormatEtc)ppEnum)._currentIndex = _currentIndex;
        return HRESULT.S_OK;
    }
}
}